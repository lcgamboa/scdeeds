const char cruntime[]=";\n"
";*****************************************************\n"
";                                                    *\n"
";       runtime library for small C compiler         *\n"
";                                                    *\n"
";       c.s - runtime routine for basic C code       *\n"
";                                                    *\n"
";               Ron Cain                             *\n"
";                                                    *\n"
";*****************************************************\n"
";\n"
"\n"
"; fetch char from (HL) and sign extend into HL\n"
"ccgchar: mov     a,m\n"
"ccsxt:  mov     l,a\n"
"        rlc\n"
"        sbb     a\n"
"        mov     h,a\n"
"        ret\n"
"; fetch int from (HL)\n"
"ccgint: mov     a,m\n"
"        inx     h\n"
"        mov     h,m\n"
"        mov     l,a\n"
"        ret\n"
"; store char from HL into (DE)\n"
"ccpchar: mov     a,l\n"
"        stax    d\n"
"        ret\n"
"; store int from HL into (DE)\n"
"ccpint: mov     a,l\n"
"        stax    d\n"
"        inx     d\n"
"        mov     a,h\n"
"        stax    d\n"
"        ret\n"
"; \"or\" HL and DE into HL\n"
"ccor:   mov     a,l\n"
"        ora     e\n"
"        mov     l,a\n"
"        mov     a,h\n"
"        ora     d\n"
"        mov     h,a\n"
"        ret\n"
"; \"xor\" HL and DE into HL\n"
"ccxor:  mov     a,l\n"
"        xra     e\n"
"        mov     l,a\n"
"        mov     a,h\n"
"        xra     d\n"
"        mov     h,a\n"
"        ret\n"
"; \"and\" HL and DE into HL\n"
"ccand:  mov     a,l\n"
"        ana     e\n"
"        mov     l,a\n"
"        mov     a,h\n"
"        ana     d\n"
"        mov     h,a\n"
"        ret\n"
";\n"
";......logical operations: HL set to 0 (false) or 1 (true)\n"
";\n"
"; DE == HL\n"
"cceq:   call    cccmp\n"
"        rz\n"
"        dcx     h\n"
"        ret\n"
"; DE != HL\n"
"ccne:   call    cccmp\n"
"        rnz\n"
"        dcx     h\n"
"        ret\n"
"; DE > HL [signed]\n"
"ccgt:   xchg\n"
"        call    cccmp\n"
"        rc\n"
"        dcx     h\n"
"        ret\n"
"; DE <= HL [signed]\n"
"ccle:   call    cccmp\n"
"        rz\n"
"        rc\n"
"        dcx     h\n"
"        ret\n"
"; DE >= HL [signed]\n"
"ccge:   call    cccmp\n"
"        rnc\n"
"        dcx     h\n"
"        ret\n"
"; DE < HL [signed]\n"
"cclt:   call    cccmp\n"
"        rc\n"
"        dcx     h\n"
"        ret\n"
"; DE >= HL [unsigned]\n"
"ccuge:  call    ccucmp\n"
"        rnc\n"
"        dcx     h\n"
"        ret\n"
"; DE < HL [unsigned]\n"
"ccult:  call    ccucmp\n"
"        rc\n"
"        dcx     h\n"
"        ret\n"
"; DE > HL [unsigned]\n"
"ccugt:  xchg\n"
"        call    ccucmp\n"
"        rc\n"
"        dcx     h\n"
"        ret\n"
"; DE <= HL [unsigned]\n"
"ccule:  call    ccucmp\n"
"        rz\n"
"        rc\n"
"        dcx     h\n"
"        ret\n"
"; signed compare of DE and HL\n"
";   carry is sign of difference [set => DE < HL]\n"
";   zero is zero/non-zero\n"
"cccmp:  mov     a,e\n"
"        sub     l\n"
"        mov     e,a\n"
"        mov     a,d\n"
"        sbb     h\n"
"        lxi     h,1             ;preset true\n"
"        jm      cccmp1\n"
"        ora     e               ;resets carry\n"
"        ret\n"
"cccmp1: ora     e\n"
"        stc\n"
"        ret\n"
"; unsigned compare of DE and HL\n"
";   carry is sign of difference [set => DE < HL]\n"
";   zero is zero/non-zero\n"
"ccucmp: mov     a,d\n"
"        cmp     h\n"
"        jnz     ccucmp1\n"
"        mov     a,e\n"
"        cmp     l\n"
"ccucmp1: lxi     h,1             ;preset true\n"
"        ret\n"
"; shift DE right logically by HL, move to HL\n"
"cclsr:  xchg\n"
"cclsr1: dcr     e\n"
"        rm\n"
"        stc\n"
"        cmc\n"
"        mov     a,h\n"
"        rar\n"
"        mov     h,a\n"
"        mov     a,l\n"
"        rar\n"
"        mov     l,a\n"
"        stc\n"
"        cmc\n"
"        jmp     cclsr1\n"
"; shift DE right arithmetically by HL, move to HL\n"
"ccasr:  xchg\n"
"ccasr1: dcr     e\n"
"        rm\n"
"        mov     a,h\n"
"        ral\n"
"        mov     a,h\n"
"        rar\n"
"        mov     h,a\n"
"        mov     a,l\n"
"        rar\n"
"        mov     l,a\n"
"        jmp     ccasr1\n"
"; shift DE left arithmetically by HL, move to HL\n"
"ccasl:  xchg\n"
"ccasl1: dcr     e\n"
"        rm\n"
"        dad     h\n"
"        jmp     ccasl1\n"
"; HL = DE - HL\n"
"ccsub:  mov     a,e\n"
"        sub     l\n"
"        mov     l,a\n"
"        mov     a,d\n"
"        sbb     h\n"
"        mov     h,a\n"
"        ret\n"
"; HL = -HL\n"
"ccneg:  call    cccom\n"
"        inx     h\n"
"        ret\n"
"; HL = ~HL\n"
"cccom:  mov     a,h\n"
"        cma\n"
"        mov     h,a\n"
"        mov     a,l\n"
"        cma\n"
"        mov     l,a\n"
"        ret\n"
"; HL = !HL\n"
"cclneg: mov     a,h\n"
"        ora     l\n"
"        jz      cclneg1\n"
"        lxi     h,0\n"
"        ret\n"
"cclneg1: inx     h\n"
"        ret\n"
"; HL = !!HL\n"
"ccbool: call    cclneg\n"
"        jmp     cclneg\n"
";\n"
"; HL = DE * HL [signed]\n"
"ccmul:  mov     b,h\n"
"        mov     c,l\n"
"        lxi     h,0\n"
"ccmul1: mov     a,c\n"
"        rrc\n"
"        jnc     ccmul2\n"
"        dad     d\n"
"ccmul2: xra     a\n"
"        mov     a,b\n"
"        rar\n"
"        mov     b,a\n"
"        mov     a,c\n"
"        rar\n"
"        mov     c,a\n"
"        ora     b\n"
"        rz\n"
"        xra     a\n"
"        mov     a,e\n"
"        ral\n"
"        mov     e,a\n"
"        mov     a,d\n"
"        ral\n"
"        mov     d,a\n"
"        ora     e\n"
"        rz\n"
"        jmp     ccmul1\n"
"; HL = DE / HL, DE = DE %% HL\n"
"ccdiv:  mov     b,h\n"
"        mov     c,l\n"
"        mov     a,d\n"
"        xra     b\n"
"        push    psw\n"
"        mov     a,d\n"
"        ora     a\n"
"        cm      ccdeneg\n"
"        mov     a,b\n"
"        ora     a\n"
"        cm      ccbcneg\n"
"        mvi     a,16\n"
"        push    psw\n"
"        xchg\n"
"        lxi     d,0\n"
"ccdiv1: dad     h\n"
"        call    ccrdel\n"
"        jz      ccdiv2\n"
"        call    cccmpbd\n"
"        jm      ccdiv2\n"
"        mov     a,l\n"
"        ori     1\n"
"        mov     l,a\n"
"        mov     a,e\n"
"        sub     c\n"
"        mov     e,a\n"
"        mov     a,d\n"
"        sbb     b\n"
"        mov     d,a\n"
"ccdiv2: pop     psw\n"
"        dcr     a\n"
"        jz      ccdiv3\n"
"        push    psw\n"
"        jmp     ccdiv1\n"
"ccdiv3: pop     psw\n"
"        rp\n"
"        call    ccdeneg\n"
"        xchg\n"
"        call    ccdeneg\n"
"        xchg\n"
"        ret\n"
"; {DE = -DE}\n"
"ccdeneg:\n"
"        mov     a,d\n"
"        cma\n"
"        mov     d,a\n"
"        mov     a,e\n"
"        cma\n"
"        mov     e,a\n"
"        inx     d\n"
"        ret\n"
"; {BC = -BC}\n"
"ccbcneg:\n"
"        mov     a,b\n"
"        cma\n"
"        mov     b,a\n"
"        mov     a,c\n"
"        cma\n"
"        mov     c,a\n"
"        inx     b\n"
"        ret\n"
"; {DE <r<r 1}\n"
"ccrdel: mov     a,e\n"
"        ral\n"
"        mov     e,a\n"
"        mov     a,d\n"
"        ral\n"
"        mov     d,a\n"
"        ora     e\n"
"        ret\n"
"; {BC : DE}\n"
"cccmpbd:\n"
"        mov     a,e\n"
"        sub     c\n"
"        mov     a,d\n"
"        sbb     b\n"
"        ret\n"
"; case jump\n"
"cccase: xchg                    ;switch value to DE. exchange HL with DE\n"
"        pop     h               ;get table address\n"
"cccase1: call    cccase4          ;get case value\n"
"        mov     a,e\n"
"        cmp     c               ;equal to switch value cc\n"
"        jnz     cccase2          ;no\n"
"        mov     a,d\n"
"        cmp     b               ;equal to switch value cc\n"
"        jnz     cccase2          ;no\n"
"        call    cccase4          ;get case label\n"
"        jz      cccase3          ;end of table, go to default\n"
"        push    b\n"
"        ret                     ;case jump\n"
"cccase2: call    cccase4          ;get case label\n"
"        jnz     cccase1          ;next case\n"
"cccase3: dcx     h\n"
"        dcx     h\n"
"        dcx     h               ;position HL to the default label\n"
"        mov     d,m             ;read where it points to\n"
"        dcx     h\n"
"        mov     e,m\n"
"        xchg                    ;exchange HL with DE and vice versa - address is now in HL\n"
"        pchl                    ;default jump. loads HL to PC\n"
"cccase4: mov     c,m\n"
"        inx     h\n"
"        mov     b,m\n"
"        inx     h\n"
"        mov     a,c\n"
"        ora     b\n"
"        ret\n"
";\n"
";\n"
";\n"
"Xstktop: lxi     h,0     ;return current stack pointer (for sbrk)\n"
"        dad     sp\n"
"        ret\n"
";        cseg\n"
"etext:\n"
";        dseg\n"
";brkend: .blkw      edata           ;current \"break\"\n"
";edata:  .blkw\n"
";\n"
";       .blkb   0H40\n"
";       .blkw   0H20\n"
";\n"
"\n"
"; fetch char from (HL) into HL no sign extend\n"
"cguchar: mov     l,m\n"
"        mvi     h,0\n"
"        ret\n"
"; unsigned divide DE by HL and return quotient in HL, remainder in DE\n"
"; HL = DE / HL, DE = DE %% HL\n"
"ccudiv: mov     b,h             ; store divisor to bc \n"
"        mov     c,l\n"
"        lxi     h,0             ; clear remainder\n"
"        xra     a               ; clear carry        \n"
"        mvi     a,17            ; load loop counter\n"
"        push    psw\n"
"ccduv1: mov     a,e             ; left shift dividend into carry \n"
"        ral\n"
"        mov     e,a\n"
"        mov     a,d\n"
"        ral\n"
"        mov     d,a\n"
"        jc      ccduv2          ; we have to keep carry -> calling else branch\n"
"        pop     psw             ; decrement loop counter\n"
"        dcr     a\n"
"        jz      ccduv5\n"
"        push    psw\n"
"        xra     a               ; clear carry\n"
"        jmp     ccduv3\n"
"ccduv2: pop     psw             ; decrement loop counter\n"
"        dcr     a\n"
"        jz      ccduv5\n"
"        push    psw\n"
"        stc                     ; set carry\n"
"ccduv3: mov     a,l             ; left shift carry into remainder \n"
"        ral\n"
"        mov     l,a\n"
"        mov     a,h\n"
"        ral\n"
"        mov     h,a\n"
"        mov     a,l             ; substract divisor from remainder\n"
"        sub     c\n"
"        mov     l,a\n"
"        mov     a,h\n"
"        sbb     b\n"
"        mov     h,a\n"
"        jnc     ccduv4          ; if result negative, add back divisor, clear carry\n"
"        mov     a,l             ; add back divisor\n"
"        add     c\n"
"        mov     l,a\n"
"        mov     a,h\n"
"        adc     b\n"
"        mov     h,a     \n"
"        xra     a               ; clear carry\n"
"        jmp     ccduv1\n"
"ccduv4: stc                     ; set carry\n"
"        jmp     ccduv1\n"
"ccduv5: xchg\n"
"        ret\n"
";\n"
"crun8080_end:";
